# Setting up a malware analysis lab with libvirt

## Network Setup
We want our malware analysis lab to include the following components:

+ A victim VM with a Windows version (Windows 10 in my case) installed on it; in order to avoid any contact with the host machine and the Internet we will need to place it in an isolated offline subnet.
+ Another victim VM with Ubuntu installed on it, for the cases when we want to analyze Linux malware samples; what was said for the Windows victim holds true for this one too.
+ An analysis machine on which we will also install Ubuntu (although for maximum security it might be better to use Windows when analyzing Linux malware so that it is less likely to spread in the worst case...); this machine will have two virtual network interfaces, one on the isolated subnet in order to communicate with the victims and the other on a subnet which can communicate with the Internet, which might be useful for a variety of purposes such as easily updating the various analysis tools. Of course the two interfaces should not be able to communicate with each other in order to prevent malware from escaping the isolated subnet, therefore they **should not**:
  - Do IP forwarding 
  - Be bridged
  - Be bound

Given our requirements, we need to define two separate virtual networks. In `libvirt`, virtual networks are represented by constructs which are called *virtual network switches* and correspond to virtual bridge interfaces on the host system. The `default` network, which typically corresponds to virtual bridge `virbr0`, comes preconfigured and allows connectivity to the host and the internet. For the isolated virtual network, since we don't want the host to be directly connected to it we need to define a new virtual switch corrisponding to a virtual bridge without IP address and without association with a physical network interface. Therefore we can create a `private_net.xml` file to represent a switch object within `libvirt` with the following minimal configuration:
```xml
<network>
  <name><net_name></name>
  <bridge name="<bridge_name>"/>
</network>
```
This file can be used to startup the network with the command `virsh net-create private_net.xml`. `<net_name>` is the name which is used to manage the network from the command line with `virsh`. On the host, the virtual network switch will be seen as a virtual bridge interface with name `<bridge_name>` and without an assigned IP.  
Notice that typically `libvirt` allows to define a DHCP server on the virtual switch in order to distribute IPs to the machines on the network, but this is not possible without having an IP assigned to the bridge interface. Since we want to prevent this, we will have to statically assign IPs to the interfaces on the private network.

## Analysis VM Setup
Setting up the analysis VM requires a few steps. Assuming that the installation image `<install_image>` is already available:  
1. Create the image where the OS will be installed with:
   ```bash
   qemu-img create -f qcow2 <hda_img> <size>
   ```
   which will create the empty `.qcow2` image `<hda_img>` with the specified size. The size can be expressed in human-readable terms, e.g. "40G" to request a size of 40 Gigabytes. Notice that using the `qcow2` format is important since it is required in order to fully make use of `libvirt` snapshotting capabilities.
2. Create the VM with the `virt-install` command, analogous to:
   ```bash
   virt-install --name <analysis_VM_name> --memory <memory_size> --cdrom <install_img> \
   --disk <hda_img>
   ```
   This will create and launch the machine, assigning to it the name `<analysis_VM_name>`. This name is what is used to manage the VM from the command line with `virsh`. Install the OS, then shutdown.
3. Notice that `libvirt` uses the SPICE protocol by default. Concerning shared folders, it should also support the `virtiofs` driver as explained in https://libvirt.org/kbase/virtiofs.html. If that approach does not work, one can try using an external `virtiofsd` as follows:  
   1. Install `libseccomp-dev`
   2. Clone the repository at https://gitlab.com/virtio-fs/qemu
   3. Inside the root folder of the repository, run `./configure -disable-werror` (else it will refuse to proceed due to warnings), then run `make virtiofsd`. 
   4. Before running the VM, run the following command from the root folder of the repository:
      ```bash
      sudo ./virtiofsd -o vhost_user_socket=<socket_file_path> -o source=<shared_folder_path> \
      -o cache=always
      ```  
      Where <shared_folder_path> is the path (on the host) of the folder to be shared. Notice that `sudo` might not be necessary, I still need to try doing without.  
   
   Once this has been done, with the VM still turned off edit the VM configuration with `virsh edit <analysis_VM_name>` as follows:
   ```xml
   <domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>
     ...
     <qemu:commandline>
       <qemu:arg value='-chardev'/>
       <qemu:arg value='socket,id=char0,path=<socket_file_path>'/>
       <qemu:arg value='-device'/>
       <qemu:arg value='vhost-user-fs-pci,queue-size=1024,chardev=char0,tag=<mount_tag>'/>
     </qemu:commandline>
   </domain>
   ```
   Where `<mount_tag>` is the tag that will need to be used from within the VM when mounting the shared folder with the command `mount -t virtiofs <mount_tag> <mount_folder`.  
   **NOTE**: It might happen that `apparmor` prevents `libvirt` from getting access to `<socket_file_path>`, thus preventing in turn the VM from starting. In order to avoid this, one can edit the file which is typically stored at `/etc/apparmor.d/libvirt/TEMPLATE.qemu` and give read (`r`), write (`w`) and lock (`k`) capabilities over `<socket_file_path>`, similar to the following:
   ```
   profile LIBVIRT_TEMPLATE flags=(attach_disconnected) {
     #include <abstractions/libvirt-qemu>
     <socket_file_path> rwk,
   }

   ```
   It is important that the comma is present, else the file will not be parsed correctly.
4. Now we need to attach the analysis  VM to the private network. In order to do this, we will add to it a new interface connected to the virtual bridge `<bridge_name>`. This can be done with the following command:
   ```bash
   virsh attach-interface --domain <analysis_VM_name> --type network --source <net_name> \
   --persistent --model virtio
   ```
   The `persistent` flag means that the interface is permanently added to the VM configuration and as such will be present even after restarting the VM.
5. The newly added interface needs of course to be configured. This can be done with `nmtui`. Select the wired connection corresponding to the interface (in my case `ens8`) and add an arbitrary IP/netmask (in my case 192.168.123.1/24) after ensuring that it is on a different subnet than the other interface (`ens3` in my case) and the host. The default gateway parameter can be left empty. 
6. One should also check and confirm that IP forwarding between the two interfaces is disabled; this can be done with the command `sudo sysctl net.ipv4.ip_forward`. If the returned value is 0, IP forwarding is already disabled on the system, else it has to be permanently disabled before proceeding, which can be done by setting `net.ipv4.ip_forward = 1` in `/etc/sysctl.conf`.
7. Finally, we can set up `iptables` rules in order to prevent unauthorized traffic between the interfaces `ens3` and `ens8`. In particular, I added the following rules:
   + Drop traffic which should be forwarded through the analysis VM in both directions (although this should already be prevented if IP forwarding is disabled). This was done with the following commands:
     ```bash
     sudo iptables -A FORWARD -i ens3 -o ens8 -j DROP
     sudo iptables -A FORWARD -i ens8 -o ens3 -j DROP
     ```
   + Drop traffic destined to the analysis VM which arrives through `ens8` but is destined to addresses outside of its subnet (192.168.123.0/24). This was done with the following command:
     ```bash
     sudo iptables -A INPUT -i ens8 ! -d 192.168.123.0/24 -j DROP
     ```
   + Drop traffic sent from the analysis VM which comes from `ens8` but is destined to addresses outside of its subnet. This was done with the following command:
     ```bash
     sudo iptables -A OUTPUT -o ens8 ! -d 192.168.123.0/24 -j DROP
     ```
   By default iptables rules last until next reboot; in order to make them persistent I used the `iptables-persistent` package, saving the rules described above with the command `iptables-save > /etc/iptables/rules.v4`.

### INetSim Setup
In order to perform malware analysis it can be useful to provide malware with a simulated Internet setting in order to make it easier for it to actually detonate. INetSim does just that; it consists in a set of fake services which are commonly used on the Internet (DNS, HTTP, HTTPS, FTP, etc.) whose only purpose is to trick malware into assuming that it is actually talking with the service it expects to while instead returning predefined responses and logging any activity it performs. Setting up INetSim is fairly easy:  
1. Log in as `root` with `sudo su`
2. Add the INetSim repository to the APT sources list and its signing key to the apt trusted keys:
   ```
   echo "deb http://www.inetsim.org/debian/ binary/" > /etc/apt/sources.list.d/inetsim.list
   wget -O - https://www.inetsim.org/inetsim-archive-signing-key.asc | apt-key add -
   ```
3. Exit the `root` shell
4. Install the `inetsim` package:
   ```
   sudo apt update
   sudo apt install inetsim
   ```
5. By default `inetsim` is enabled as a system-wide service after being installed, but one might want to be able to customize its configuration depending on specific analysis settings. In this case it might be more effective to disable the service and store all required configuration data in a dedicated subdirectory for each analysis attempt. Below we show an example of this procedure, assuming we hold our individual analysis subdirectories under a main `~/analysis` folder. In particular, in order to permanently disable the `inetsim` service we run the following commands:
   ```
   sudo service inetsim stop
   sudo systemctl disable inetsim
   ```
   The following commands are instead required everytime we want to create a new subfolder (named in this case `example_analysis`) to hold a custom inetsim configuration:
   ```
   mkdir ~/analysis/example_analysis
   sudo cp /etc/inetsim/inetsim.conf ~/analysis/example_analysis/inetsim.conf
   sudo cp -r /var/lib/inetsim ~/analysis/example_analysis/data
   mkdir -p ~/analysis/example_analysis/log/report
   sudo chmod -R ugo+rw ~/analysis/example_analysis/data
   cd ~/analysis/example_analysis
   ```
6. Edit the configuration of `inetsim` stored in the file `inetsim.conf`; the most important parameters to edit are `service_bind_address` and `dns_default_ip`, which should be set to the address of the interface facing the private network. Additionally, since we will proxy `https` through BurpSuite, we should set the INetSim HTTPS service to listen on a different port by setting the parameter `https_bind_port` to an arbitrary free port (in my case port 8443). If needed, one can also edit the *fakefiles* sections in order to allow the download of specific binaries (which will need to be stored in the folder `data/http/fakefile/`) when the victim browses to URLs with specific characteristics (e.g. a specific extension).
7. Notice that it might happen that the INetSim HTTPS server does not properly work; if that is the case, check the `default_cert.pem` and `default_key.pem` files stored in the folder `data/certs/`; it might happen that they are for some reason owned by users which are different from the `inetsim` user on the system and this prevents the INetSim HTTPS service from using it. Although this should be avoided by giving read and write permissions to everyone on those files, one could also solve the issue by changing the owners of those files to `inetsim` with `chmod`.
8. `inetsim` can then be run with the custom configuration using the following command:
   ```
   sudo inetsim --data data --config inetsim.conf --log-dir log --report-dir log/report
   ```

### BurpSuite Setup
By itself, INetSim does not handle HTTPS very well, since it is not able to generate SSL certificates on the fly; for this reason, we will place BurpSuite as a transparent proxy between it and the victims, so that it will handle the task of providing "valid" certificates on its behalf. In order to do this, we will need to allow BurpSuite to listen on port 443, which will be done through the `authbind` package in order to avoid having to run it as `root`. Moreover, to be on the safe side, we will run it as the special `inetsim` user which is also used to run INetSim services rather than with our "main" user account.
1. Download the BurpSuite Community installation script from https://portswigger.net/burp/communitydownload and execute it. By default, this will place the main executable at `~/BurpSuiteCommunity/BurpSuiteCommunity`.
2. Install the `authbind` package from APT.
3. Execute the following commands:
   ```
   sudo -u inetsim touch /etc/authbind/byport/443
   sudo chmod u+x /etc/authbind/byport/443
   ```
   This will allow BurpSuite to freely listen on port 443 when run as user `inetsim` through `authbind`.
4. Before trying to run BurpSuite as `inetsim`, we need to allow this user to use our "main" user's desktop to display the window. In order to do this in a persistent way, we can add the following lines at the end of the file `/etc/profile`:
   ```bash
   if [ "$DISPLAY" != "" ]
   then
        xhost +local:inetsim
   fi
   ```
5. At this point we can actually run BurpSuite as user `inetsim` with the following command:
   ```
   sudo -u inetsim authbind --deep ~/BurpSuiteCommunity/BurpSuiteCommunity
   ```
6. In BurpSuite's window go to *Proxy > Options*, select the default Proxy Listener and *Edit* it. In the *Binding* panel bind to port 443 and to the *Specific address* corresponding to the address of the interface where INetSim is listening (192.168.123.1 in my case); in the *Request handling* panel set the *Redirect to host* parameter to that same address and the *Redirect to port* parameter to the port assigned to INetSim's HTTPS server (port 8443 in my case) so that the received HTTPS request can be handled by INetSim's HTTPS server. Tick the box *Support invisible proxying*.
7. BurpSuite should now be fully operational. In order to avoid having to repeat the setup procedure at every new analysis attempt, save the configuration with *Save project options*. 

### Wireshark Setup
After installing `wireshark` from APT, add the `inetsim` user to the `wireshark` group with `sudo usermod -a -G wireshark inetsim`; after doing this we can directly run it on the interface facing the private network as user `inetsim` with `sudo -u inetsim wireshark` in order to sniff the traffic on that network.

## Setting up the Ubuntu victim VM
The setup of the Ubuntu victim VM is fairly simple; once the OS has been installed, there is not too much we have to do. Assuming the VM was created with a `virt-install` command line similar to the one used for the analysis machine, after the initial setup it should have connectivity to the internet since if no other options are specified `libvirt` automatically provides the machine with an interface on the `default` virtual network. Use this in order to install or update any necessary package (including `resolvconf`, which will be needed later), then attach a new interface which we will connect to the isolated network and detach the original one. Assuming the VM name is `<ubuntu_victim_name>`, this corresponds to the following commands:
```bash
virsh attach-interface --domain <ubuntu_victim_name> --type network --source <net_name> \
--persistent --model virtio
virsh detach-interface --domain <ubuntu_victim_name> --type network --mac <mac_address> \
--persistent
```
Where `<mac_address>` is the MAC address of the interface to be detached. After this has been done, use `nmtui` in order to provide a static IP address to the attached interface and setup the address of the interface where INetSim is listening (192.168.123.1 in my case) as default gateway, so that this address will be the one contacted by the machine everytime it needs to reach the outside network. Of course the IP given to the victim machine must be in the same subnet as the interface where INetSim is listening!   
In order for the machine to use the fake DNS provided by INetSim we also need to configure the DNS server. `resolvconf` allows us to easily make the configuration persistent across reboots, by simply writing the ip on which INetSim is listening in the file `/etc/resolvconf/resolv.conf.d/tail`.
Additionally, if we want to maximize the distance between victim VMs and the host we might want to avoid shared folders, clipboard sharing and the mouse integration features provided by the SPICE guest agent. These features can be disabled by running the command `virsh edit <ubuntu_victim_name>` when the VM is turned off and modifying the configuration by removing any `tablet` device definition and introducing the following within the `graphics` tags (assuming they have `type='spice'` set):
```xml
<mouse mode='server'/>                                                   
<clipboard copypaste='no'/>                                              
<filetransfer enable='no'/>
```
Furthermore, several malware samples use very simple techniques in order to detect whether they are being executed within a VM and act accordingly (mostly by simply refusing to execute their malicious payload); in order to make this approach harder for them, we should explicitly:
1. Disable the CPUID "hypervisor present" bit  
2. Disable the hypervisor CPUID leaves, which can be used by the hypervisor to store identifying information such as its own signature.  

This can again be done by running the command `virsh edit <ubuntu_victim_name` and modifying the configuration in two points. In particolar, in order to disable the "hypervisor present" bit specify the `<cpu>` section as such:
```xml
<cpu mode='host-model' check='partial'>
  <feature policy='disable' name='hypervisor'/>
</cpu>
```
The CPUID leaves can instead be disabled by inserting the following inside the `<features>` tags:
```xml
<kvm>
  <hidden state='on'/>
</kvm>
```   
As a final step, in order to implicitly trust the certificates generated by BurpSuite when using `https` it is necessary to install its root certificate on the system. In order to do this, first from within Burp add a second proxy listener on port 8080 of the interface facing the private network, then from the victim machine browse to `http://<listener_interface_ip>:8080` and click on the link "CA Certificate" in order to download the certificate in DER format `<der_file>`. Then execute the following commands:
```
sudo openssl x509 -in <der_file> -inform DER -out /usr/local/share/ca-certificates/burp.crt
sudo update-ca-certificates
```  
Notice that in order to install the certificate on the Firefox browser too a different procedure must be followed, by going into the *Certificates* section of the settings and then selecting *View Certificates > Import...*; click on the certificate file and then tick *Trust this CA to identify websites*.
Now the Ubuntu victim VM should be ready. As a good practice one should now use `virsh snapshot-create` in order to save a snapshot of the VM ready for use, so that it can be reverted to a clean state using `virsh snapshot-revert` after any analysis attempt. If the VM needs an actual internet connection for any reason (assuming it is in a clean state), one can simply temporarily attach a new interface connected to the `default` network, temporarily remove the INetSim fake DNS server from the configuration if necessary, perform the required operations and then detach it in a similar way as described above. After that, it is possible to make a snapshot of the updated clean state. Alternatively, remember that the INetSim HTTP Fakefile service can also be used to transfer files from the analysis machine to the victim machines.

## Setting up the Windows 10 victim VM
The setup for the Windows 10 victim VM is in several aspects similar to the one described for the Ubuntu victim VM, with a few differences. Assuming the VM is originally created with connectivity to the internet (default configuration), install all the necessary tools including the `OpenSSH Server` *optional feature*, which we will use in order to allow the transferral of files between this machine and the analysis machine through `scp`. After this, perform the procedure described above in order to replace the interface connected to the `default` virtual network with an interface connected to the `<net_name>` private virtual network and manually configure the interface by giving it an IP (which will have to be in the same subnet as the interface where INetSim is listening), a default gateway (which will be the IP assigned to the interface where INetSim is listening) and a DNS server (same).  
The same observations made for the Ubuntu victim VM concerning the folder/clipboard sharing and mouse integration hold true for the Windows 10 VM too and can be implemented in the same way; the same also goes for what concerns hiding the true nature of the VM.  
In order to have the OpenSSH server be persistently running across reboots, open the Windows PowerShell with administrator privileges and execute the following commands:
```powershell
Start-Service -Name "sshd"
Set-Service -Name "sshd" -StartupType Automatic
```
In order to implicitly trust the certificates generated by BurpSuite when `https` is being used, install its root certificate as explained for the Ubuntu victim VM, with the difference that in order to install the downloaded certificate on the system one only has to open it and then follow the instructions, selecting *Place all certificates in the following store* and then *Trusted Root Certification Authorities* when prompted.   
Additionally, one might want to disable the Windows Defender Firewall and Microsoft Defender Antivirus components in order to facilitate the infection when analyzing a malware. While the former can be persistently disabled without difficulties, the latter is in normal conditions automatically enabled by the system when disabled for a prolonged period of time. In order to prevent this and in particular keep the Real-Time Protection functionality in the disabled state I followed the procedure described below:
1. Turn off "Tamper Protection" in the Windows Defender Settings
2. In the Local Group Policy Editor, enable policies `Computer Configuration > Administrative Templates > Windows Components > Windows Defender Antivirus > Turn off Windows Defender Antivirus` and `Computer Configuration > Administrative Templates > Windows Components > Windows Defender Antivirus > Turn off routine remediation`
3. In the Registry Editor:
   1. Add a `REG_DWORD` entry with name `DisableAntiSpyware` and value 1 at `Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender`
   2. If needed, create key `Real-Time Protection` under `Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender`
   3. Under `Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection`, add the following `REG_DWORD` entries with value 1:
      + `DisableBehaviorMonitoring`
      + `DisableRealtimeMonitoring`
      + `DisableOnAccessProtection`
      + `DisableScanOnRealtimeEnable`
4. Reboot the VM  

Once all this has been done, the VM should be ready to be used; as for the Ubuntu victim VM, take a snapshot of the current clean state in order to be able to restore it after each analysis attempt. When an actual internet connection is needed, if the machine is in a clean state one can temporarily attach to it an interface connected to the `default` network and disable the other, perform the required operations and then return to its original configuration; alternatively, the INetSim HTTP Fakefile feature can be used to transfer files from the analysis machine to the victims.
